### 数字类型   
ECMAScript中的Number类型使用 IEE754 标准来表示整数和浮点数值。所谓 IEEE754标准，全称 IEEE二进制浮点数算数标准，这个标准定义了表示浮点数的格式等内容。  
在IEEE754中，规定了四种表示浮点数值的方式：单精确度(32位)、双精确度(64位)、延伸单精确度、与延伸双精确度。像ECMAScript采用的就是双精确度，也就是说，会用64位字节来存储一个浮点数。  
### 浮点数转二进制  
如果 0.75 用二进制来表示：
`0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...`  
因为使用的是二进制，abcd...的值要么是0要么是1。  
为计算abcd...的值，两边同时不停乘以2算出来，解法如下：  
`0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...`  
两边同时乘以2  
`1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * c^-3...(a = 1)`
剩下的：  
`0.5 = b * 2^-1 + c * 2^-2 + d * c^-3...`  
再同时乘以2  
`1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3... (所以 b = 1)`  
所以0.75用二进制表示就是0.ab,也就是0.11。  
然而并不是所有的数都像0.75这么好算，比如0.1：  
```
0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...  

0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)  
0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)  
0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)  
1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)  
1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)  
0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)  
0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)  
1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)  
```
然后就会发发现，这个计算在不停的循环，所以0.1用二进制表示就是0.00011001100110011...  
### 浮点数的存储  
虽然0.1转成二进制时是一个无限循环的数，但计算机总要存储吧，我们知道ECMAScript使用64位字节来存储一个浮点数，那么具体是怎么存储的呢？这就要说回IEEE754这个标准了，毕竟是这个标准规定了存储的方式。  
这个表述认为，一个浮点数(Value)可以这样表示：  
`Value = sign * exponent * fraction`  
看起来很抽象的样子，简单理解就是科学计数法。  
比如-1020，用科学计数法表示就是：  
`-1 * 10^3 * 1.02`  
sign 就是 -1，exponent就是 10^3，fraction就是1.02  
对于二进制也是一样，以0.1的二进制0.0001100110011...这个数来说：  
可以表示为：  
`1 * 2^-4 * 1.1001100110011...`  
其中sign就是1，exponent就是2^-4，fraction就是1.1001100110011...  
而当只做二进制科学计数法的表示时，这个Value的表示可以再具体一点变成：  
`V = (-1)^S * (1 + Fraction) * 2^E`  
(如果所有的浮点数都可以这样表示，那么我们存储的时候就把这其中会变化的一些值存储起来就好了)  
一点点来看：  
`(-1)^S` 表示符号位，当S = 0,V为正数；当S=1, V为负数。  
再看`(1 + Fracction)`,这是因为所有浮点数都可以表示为 1.xxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxx 好了，这也就是 Fraction 的部分。  
最后再看 `2^E`  
如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9, E的值就是9，而如果是0.1，对应二进制是 1 * 1.1001100110011...* 2……-4，E的值就是 -4， 也就是说，E既可能是负数，又可能是正数，那问题就来了，我们该怎么存储这个E呢？  
我们这样解决，假如我们用8位字节来存储E这个数，如果只有正数的话，存储的范围是0~254，而如果要存储正负数的话，值的范围就是-127~127，我们存储的时候，把要存储的数字加上127，这就当我们存 -127 的时候，我们存0，当存127的时候，存254，这样就解决了存负数的问题。对应的，当取值的时候，我们再减去127。  
所以呢，真到实际存储的时候，我们并不会直接存储E，而是会存储E + bias，当用8个字节的时候，这个bias就是127。  
所以，如果要存储一个浮点数，我们存S 和 Fraction和 E + bias这三个值就好了，具体要分配多少个字节位来存储这些数，IEEE754给出了标准：  
![IEEE754](https://camo.githubusercontent.com/961b2b4ca090b3fa649ad71317828c0fe95d71c1/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067)  
在这个标准下:
我们会用1位存储S, 0表示正数，1表示负数。  
用11位存储E + bias，对于11位来说，bias的值是2^(11 - 1) - 1,也就是 1023。  
用52位存储Fraction、  
举个例子，就拿0.1来看，对应二进制是 1* 1.1001100110011...* 2……-1，Sign是0，E + bias是-4 + 1023 = 1019，1019用二进制表示是1111111011，Fraction是1001100110011...  
对应64个字节位的完整表示就是：  
`0 01111111011 1001100110011001100110011001100110011001100110011010`  
同理，0.2表示的完整表示是：  
`0 01111111100 1001100110011001100110011001100110011001100110011010`  
所以当0.1存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。  
### 浮点数的运算  
关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下0.1和0.2的计算。  
首先是对阶，所谓对阶，就是把阶码调整为相同，比如0.1是`1.1001100110011…… * 2^-4`,阶码是-4，而0.2就是`1.10011001100110...* 2^-3`,阶码是-3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是0.1的-4调整为-3，对应变成`0.11001100110011…… * 2^-3`  
接下来是尾数计算：  
```
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
————————————————————————————————————————————————————————
 10.0110011001100110011001100110011001100110011001100111
```
我们得到的结果为 `10.0110011001100110011001100110011001100110011001100111 * 2^-3`  
将这个结果处理一下，即结果规格化，变成  
`1.0011001100110011001100110011001100110011001100110011(1) * 2^-2`  
括号里的1意思是说计算后这个1超出了范围，所以要被舍弃了。  
再然后是舍入，四舍五入对应到二进制中，就是0舍1入，因为我们要把括号里的1丢了，所以这里会进1，结果变成  
`1.0011001100110011001100110011001100110011001100110100 * 2^-2`  
本来还有一个溢出判断，因为这里不涉及，就不讲了。  
所以最终的结果存成64位就是  
```0 01111111101 0011001100110011001100110011001100110011001100110100```  
将它转换为10进制数就得到`0.30000000000000004440892098500626`  
因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了0.1 + 0.2 !== 0.3 



