[Performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)  
[性能监测对象 PerformanceObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver)   
[Node Performance measurement APIs](https://nodejs.org/api/perf_hooks.html#perf_hooks_perf_hooks_performance)  

### 性能优化  
[JavaScript引擎基础：Shapes和Inline Caches](https://hijiangtao.github.io/2018/06/17/Shapes-ICs/)    
[JavaScript Just-in-time(JIT)工作原理](https://www.w3ctech.com/topic/2026)  

> 在代码的世界中，通常有两种方式来翻译机器语言：解释器（interpreter）和编译器（compiler）。  

***如果是通过解释器，翻译是一行行地边解释边执行。***  
***编译器是把源代码整个编译成目标代码，执行时不需要编译器，直接在支持目标代码的平台上运行。***  

### 解释器的利弊  
解释器启动和执行的更快，你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行。  
正因如此，解释器看起来更适合JavaScript。对于一个Web开发人员来讲，能够快速执行代码并看到结果是非常重要的。  
这就是为什么最开始的浏览器都是用JavaScript解释器的原因。  
可是当你运行同样的代码一次以上的时候，解释器的弊端就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。  

### 编译器的利弊  
编译器的问题则恰好相反。  
它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。  
另外一个不同是，编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。  

### Just-in-time 编译器：综合了两者的优点  
为了解决解释器的低效问题，后来的浏览器把编译器也引入进来，形成了混合模式。  
不同的浏览器实现这一功能的方式不同，不过其基本思想是一致的。在JavaScript引擎中增加一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。  

起初，监视器监视着所有通过解释器的代码。  
如果同一行代码运行了几次，这个代码段就被标记成了'warm'，如果运行了很多次，则被标记为'hot'。  

### 基线编译器  
如果有单代码变成了'warm'，那么JIT就把它送到编译器去编译，并且把编译结果存储起来。  
代码段的每一行都会被编译成一个“桩”(sub)，同时给这个桩分配一个以“行号+变量类型”的索引。如果监视器监视到了执行同样的代码和同样的变量类型，那么就直接把这个已编译的版本push出来给浏览器。  

通过这样的做法可以加快执行速度，但是正如前面所说，编译器还可以找到更有效地执行代码的方法，也就是做优化。  

基线编译器可以做一部分这样的优化，不过基线编译器优化的时间不能太久，因为会使得程序的执行在这里hold不住。  

不过如果代码确实非常'hot'(也就是说几乎所有的执行时间都耗费在这里)，那么花点时间做优化也是值得的。  

### 优化编译器  
如果一个代码段变得'very host',监视器会把它发送到优化编译器中。生成一个更快速和高效的代码版本出来，并且存储之。  

为了生成一个更快速的代码版本，优化编译器必须做一些假设。例如，它会假设由同一个构造函数生成的实例都有相同的形状--就是说所有的实例都有相同的属性名，并且都以相同的顺序初始化，那么就可以针对这一模式进行优化。  

整个优化器起作用的链条是这样的，监视器从他所监视代码的执行情况做出自己的判断，接下来把它所整理的信息传递给优化器进行优化。如果某个循环中先前每次迭代的对象都有相同的形状，那么就可以认为它以后迭代的对象的形状都是相同多的。可是对于JavaScript从来就没有保证这么一说，前99个对象保持着形状，可能第100个就减少了某个属性。  

正式由于这样的情况，所以编译代码需要在运行之前检查其假设是不是合理的。如果合理，那么优化的编译代码会运行，如果不合理，那么JIT会认为做了一个错误的假设，并且把优化代码丢掉。  

这是（发生优化代码丢弃的情况）执行过程将会回到解释器或者基线编译器，这一过程叫做**去优化**。  

通常优化编译器会使得代码变得更快，但是一些情况也会引起一些意想不到的性能问题。如果你的代码一直陷入优化去优化的怪圈，那么程序执行将会变慢，还不如基线编译器快。  

大多数的浏览器都做了限制，当优化/去优化循环发生的时候会尝试跳出这种循环。比如，如果 JIT 做了 10 次以上的优化并且又丢弃的操作，那么就不继续尝试去优化这段代码了桩。  


### 总结  
简而言之JIT是什么呢？它是使JavaScript运行更快的一种手段，通过监视代码的运行状态，把`hot`代码（重复执行多次的代码）进行优化。通过这种方式，可以使JavaScript应用的性能提升很多倍。  

为了使执行速度更快，JIT会增加很多多余的开销，这些开销包括：  
* 优化和去优化开销  
* 监视器记录信息对内存的开销  
* 发生去优化情况时恢复信息的记录对内存的开销  
* 对基线版本和优化后版本记录的内存开销  



**[v8引擎官网](https://v8.dev/)**  

