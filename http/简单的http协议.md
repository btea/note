## 简单的http协议
### HTTP协议用于客户端和服务端之间的通信
HTTP协议和TCP/IP协议族内的其他众多协议相同，用户客户端和服务端之间的通信。  
请求访问文本或图像等资源的一段称为客户端，而提供资源响应的一端称之为服务端。  
在两台计算机之间使用HTTP协议通信时，在一条通信线路上必有一端是客户端，另一端是服务端。  
有时候，按实际情况，两台计算机作为客户端和服务端的角色可能会互换。但就仅从一条通信线路来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务端。  
### 通过请求和响应的交换达成通信
HTTP协议规定，请求从客户端发出，最后服务端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务端在没有接收到请求之前不会发送响应。
### HTTP是不保存状态的协议
HTTP是一种不保存状态的协议，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。  
使用HTTP协议，每当有新请求发送时，就会有对应的响应产生。协议本身并不保留之前的一切的请求或响应报文的信息。这是为了更快地处理大量事物，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。  
可是，随着web的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要继续保持登录状态。针对这个实例，网站为了能够掌握是谁发送的请求，需要保存用户的状态。  
HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。
### 请求URI定位资源
HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。
### 告知服务器意图的HTTP方法
以下为HTTP/1.1中可使用的方法：

方法名    |  说明
----------| ---------
GET(获取资源)   |  GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGT(Common Gateway Interface, 通用网关接口)那样的程序，则返回经过执行后的输出结果。  
POST(传输实体主体)| POST方法用来传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能和GET很相似，但POST的主要目的并不是获取响应主体的内容。  
PUT(传输文件)   | PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。  但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的web网站不使用该方法。若配置web应用程序的验证机制，或架构设计采用REST(Representational State Transfer,表征状态转移)标准的同类web网站，就可能会开放使用PUT方法。  
HEAD(获得报文首部) |  HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源日期更新等。  
DELETE(删除文件)   | DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。  但是,HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般web网站也不使用DELETE方法。当配合web应用程序的验证机制，或遵守REST标准时还是有可能开放使用的。  
OPTIONS(询问支持的方法) | OPTIONS方法用来查询针对请求URI指定的资源支持的方法。  
TRACE(追踪路径)   |  TRACE方法是让web服务器端将之前的请求通信返回给客户端的方法。  发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务端则返回状态码200 OK的响应。  客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是 因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认 连接过程中发生的一系列操作。  但是，TRACE方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。  
CONNECT(要求用隧道协议连接代理) | CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。 主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

### 使用方法下达命令
向请求URI指定的资源发送请求报文时，采用称为方法的命令。  
方法的作用在于，可以指定请求的资源按期望产生某种行为。
### 持久连接节省通信量
HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。
### 持久连接
为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0提出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive或HTTP conneciton reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接。  
持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样web页面的显示速度也就相应提高了。  
在HTTP/1.1中，所有连接默认都是支持持久连接，但在HTTP/1.0内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够在支持。毫无疑问，除了服务器端，客户端也需要支持持久连接。
### 管线化
持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求 后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
### 使用Cookie的状态管理
HTTP是无协议状态，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。  
假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那 么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。  
不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单 的，所以才会被应用在各种场景里。    
保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技 术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。  
Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信 息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自 动在请求报文中加入Cookie值后发送出去。  
服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的 连接请求，然后对比服务器上的记录，最后得到之前的状态信息。









