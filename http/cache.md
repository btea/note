### [http权威指南知识点总结](https://github.com/btea/http)  

HTTP(Hyper Text Transfer Protocol)构建在TCP(Transmission Control Protocol)之上。在HTTP早期实现中，每个HTTP请求都要打开一个socket连接。
这样做效率很低，因为一个web页面中的很多HTTP请求都指向同一个服务器。  
持久连接(Persistent Connection)的引入解决了多对一请求服务器导致的socket连接低效性的问题。

#### Expires头
浏览器（和代理）使用缓存来减少http请求的数量，并减少HTTP响应的大小，使web页面加载得更快。web服务器使用Expires头来告诉Web接护短它可以使用一个组件的当前副本，直到指定的时间为止。HTTP规范中简要地称该头尾“在这一日期/时间之后，响应被认为是无效的”。它在HTTP响应中发送。

#### Max-Age和mod_expires
在解决缓存如何很好地改善传输性能之前，需要提及除了Expires头之外的另一种选择。HTTP1.1引入了Cache-Control头来客服Expires头的限制。因为Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步。另外，过期日期需要经常检查，并且一旦未来这一天到了，还需要在服务器配置中提供一个新的日期。  
换一种方式，Cache-Control使用max-age指令指定组件间被缓存多久。它以秒为单位定义了一个更新窗。如果从组建被请求开始过去的秒数少于max-age，浏览器就使用缓存的版本，这就避免了额外的HTTP请求。一个长久的max-age头可以将刷新窗设置为未来10年。  
使用带有max-age的Cache-Control可以消除Expires的限制，但对于不支持HTTP1.1的浏览器，你可能仍然希望提供Expires头，你可以同时指定这两个响应头——Expires和Cache-Control max-age。如果两者同时出现，HTTP规范规定max-age指令将重写Expires头。

#### 缓存
缓存的种类：私有缓存和共享缓存。  
共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。  
##### （私有）浏览器缓存
私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过HTTP下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供内容的离线浏览。
##### （共享）代理缓存  
共享缓存可以被多个用户使用。例如，ISP或你所在公司可能架设一个web代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。  

#### 缓存控制
#### Cache-Control控制头
HTTP/1.1定义的Cache-Control头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。
##### 禁止进行缓存
缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
Cache-Control: no-store
##### 强制确认缓存
如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发送到服务器（该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（实际就是缓存304），则缓存才使用本地副本。  
Cache-Control：no-cache
##### 私有缓存和公共缓存
"public"指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public",则一些通常不被中间人缓存的页面（因为默认是private）(比如带有HTTP验证信息（账号密码）的页面或某些特定状态码的页面)，将会被其缓存。  
而"private"则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。  
Cache-Control: private  
Caceh-Control: public
##### 缓存过期机制
过期机制中，最重要的指令是"max-age=<seconds>",表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。  
Cache-Control: max-age=31536000  
##### 缓存验证确认
当使用了"must-revalidate"指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，以过期的缓存就不被使用。  
Cache-Control：must-revalidate
#### Pragma头
Pragma是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control：no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-Control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。

#### 新鲜度
理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。用于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做"缓存驱逐"。另一方面，当服务器上面的资源进行了更新，那么缓存中对应的资源也应更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端更新，所以双方必须为该资源约定一个过期时间，在该过期时间内，该资源（缓存副本）是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存的副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，发给目标服务器，以此来检查该副本是否依然是新鲜的，若服务器返回304（Not Modified）（该响应不会带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过If-None-Match或If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

#### 缓存验证
当用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里有"Cache-control: must-rvalidate"的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced ->Cache为强制验证缓存也能达到相同效果。  
当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。




