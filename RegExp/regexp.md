## 正则匹配位置  
^、$、\b、\B、(?=p)、(?!p)
### ^ 和 $
^(脱字符) 匹配开头，在多行匹配中匹配开头  
$(美元符号)匹配结尾，在多行匹配中匹配结尾  

### \b 和 \B
\b 是单词边界，具体就是\w 和 \W之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。
(注：\w 是字符组[0-9a-zA-Z_]的简写
\B 就是 \b的反面，非单词边界。例如在字符串中所有位置中，扣掉\b,剩下的都是 \B的。具体来说就是 \w 与 \w,
\W 与 \W,^ 与 \W , \W 与 $之间的位置。

### (?=p) 和 (?!p)  
(?=p), 其中 p是一个子模式，即p前面的位置，或者说，该位置后面的字符要匹配p。
比如，(?=l),表示“l”字符前面的位置。
(?!p), 表示(?=p)的反面的意思。  
二者的学名分别是 positive lookahead（正向先行断言） 和 negative lookahead（负向先行断言）。  
栗子：数字千位分隔符表示法  
'123456789'.replace(/(?!^)(?=(\d{3})+$)/g, ',')  => '123,456,789'

## 反向引用
\1  \2  \3、、、  
\1 表示匹配第一个分组内容， \2 表示匹配第二个分组内容，当多个括号嵌套时，以左括号（开括号）为准。  

## 非捕获括号
### (?:p) 和 (?:p1|p2|p3)
栗子：将每个单词的首字母转换为大写
```javascript
function titleize(str) {
    return str.toLowerCase().replace(/(?:^|\s)\w/g, function(c) {
        return c.toUpperCase()
    })
}
```
栗子：驼峰化
```javascript
function camelize(str) {
    return sre.replace(/[-_\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : ''
    })
}
```
栗子：中划线化(逆驼峰化)
```javascript
function dasherize(str) {
    return str.replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase()
}
```
## HTML转义和反转义
### 将html特殊字符转义成等值的实体
```javascript
function escapeHTML(str) {
    var escapeChars = {
        '<': 'lt',
        '>': 'gt',
        '"': 'quot',
        '&': 'amp',
        '\'': '#39'
    }
    return str.replace(new RegExp('[' + Object.keys(escapeChars).join('') + ']'), 'g'), function(match) {
        return '&' + escapeChars[match] + ';'
    })
}
```
### 实体字符转义成等值的HTML
```javascript
function unescapeHTML(str) {
    var htmlEntities = {
        nbsp: ' ',
        lt: '<',
        gt: '>',
        quot: '"',
        amp: '&',
        apos: '\''
    }
    return str.replace(/\&([^;]+);/g, function(match, key) {
        if (key in htmlEntities) {
            return htmlEntities[key]
        }
        return match
    })
}
```
## 回溯
回溯法也称试探法，它的基本思想是：从问题的某一状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜多，知道所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。

本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称之为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。
### 贪婪量词
比如 ```b{1, 3}```,因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试"bbb"，然后再看整个正则能否匹配。不能匹配时，吐出一个"b",即在"bb"的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行，只能说明匹配失败了。
### 惰性量词
惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配。
### 分支结构
我们分支也是惰性的，比如```/can|candy/```，去匹配字符串"candy"，得到的结果是"can"，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。
分支结构，可能前面的子模式会形成局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。
### 回溯法
简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。
- 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。
- 惰性量词“试”的策略是：买东西加价。给捎了，再多给点行不，还是有点少，再给点。
- 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。
